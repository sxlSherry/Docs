# Mysql 总结

[TOC]

​		因为有归集的业务，公司的归集表数据量还是很大的。算是再整合总结一下mysql的优化，之后也会有陆续有补充的。

## 1. 数据表设计

### 1.1 数据类型

  数据类型的选择原则：更简单或者占用空间更小。

- 如果长度能够满足，整型尽量使用tinyint、smallint、medium_int而非int。
- 如果字符串长度确定，采用char类型。
- 如果varchar能够满足，不采用text类型。
- 尽量采用timestamp而非datetime，相比datetime，timestamp占用更少的空间，以UTC的格式储存自动转换时区。

### 1.2 避免空值

   MySQL中字段为NULL时依然占用空间，会使索引、索引统计更加复杂。从NULL值更新到非NULL无法做到原地更新，容易发生索引分裂影响性能。尽可能将NULL值用有意义的值代替，也能避免SQL语句里面包含`is not null`（可能导致不走索引）的判断。

### 1.3 表结构优化

1. **垂直拆分**
   对于表过宽，包含text或blob字段的场景。把主键和一些常用的字段放到一个表中，把主键和不常用的列或text/blob列放到另外的表中存储。

2. **水平拆分**
   对于表中数据量过大，历史数据查询次数很少的场景，根据某一列的值把数据放到多个独立的表中，比如历史数据放到另一张表里。

3. **逆规范化**
   增加冗余列：在多个表中具有相同的列，避免联合查询。虽然不太符合数据库设计三大范式，但是对于表数据量大的情况比较好用。
   增加派生列：增加的列来自其他表的计算结果，可避免使用函数。
   重新组表：将经常联合查询的表组成一个表，减少联合查询。

### 1.4 其他

1. 建表的时候尽量不使用外键约束，用应用程序保证数据准确性。
2. 适当冗余字段，尝试创建中间表，用应用程序计算中间结果，用空间换时间。

## 2. 索引优化

​		在优化表的时候，索引优化是能起到最直接的效果的。

### 2.1 索引分类

1. 普通索引：最基本的索引。
2. 组合索引：多个字段上建立的索引，能够加速复合查询条件的检索。
3. 唯一索引：与普通索引类似，但索引列的值必须唯一，允许有空值。
4. 组合唯一索引：列值的组合必须唯一。
5. 主键索引：特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用primary key约束。
6. 全文索引：用于海量文本的查询，MySQL5.6之后的InnoDB和MyISAM均支持全文索引。

### 2.2 索引优化	

1. 最适合索引的列是在where子句中的列，或连接子句中的列，而不是出现在select关键字后的列。
2. 单表索引数不超过5个、单个索引字段数不超过5个。索引过多，会导致磁盘占用较高，insert和update操作耗时增加，查询优化效率会变低。
3. 使用短索引。如果对字符串列进行索引，应该指定一个前缀长度，前缀长度控制在5-8个字符。
4. 字段唯一性太低，增加索引没有意义，如：是否删除、性别，**查询数据量超过表数据量的30%，MYSQL不会使用索引**。
5. 利用最左前缀。比如创建了一个多列组合索引 index_c1_c2_c3 (c1,c2,c3)，相当于创建了(c1)单列索引，(c1,c2)的组合做引以及(c1,c2,c3)的组合索引。根据这个原则，在创建多列索引时，要根据业务需求 ，where子句中使用最频繁的一列要放在索引的最左边。
6. 合理使用覆盖索引。

### 2.3 索引失效情况

1. 以%开头的like查询不能使用索引。

2. 数据类型出现隐式转换的不能使用索引。数据INT类型，而用varchar查询。这个是隐形错误，上次看到同事就不小心犯了。

3. 复合索引的情况下，假如查询条件不包含索引列最左边部分，不使用索引。如果最左索引用了范围，后面的索引也会失效。

4. 在索引列上使用 MySQL 的内置函数或进行运算，索引会失效。
5. 索引字段上使用 is null 或 is not null，可能导致索引失效
6. 查询数据量超过表数据量的30%，MYSQL不会使用索引。

5. 用or分隔开的条件，如果or前的列中有索引，而后边的列中没有索引，不会使用索引。（or的所有条件必须全部使用索引字段才会走索引）。

## 3. 其他优化

  之前修改以前的代码，发现很多应用程序业务的问题，给数据库带来太大压力了，所以建议大家业务比较复杂的时候，尽量让数据库少干活，应用程序多干活，数据查出来之后用程序去处理逻辑的问题。